---
title: Setting up Persisted Queries with Relay and Strawberry GraphQL
date: '2024-11-08'
tags: ['python', 'graphql', 'relay', 'react']
draft: true
summary: In this tutorial, we demonstrate how to integrate Strawberry GraphQL with Relay to enable persisted queries, enhancing the performance of GraphQL applications. We cover the setup of a Relay environment on the client side, provide a Python script to run a GraphQL server that handles persisted queries, and create a custom schema extension for managing those queries. By leveraging persisted queries, developers can efficiently reference and execute stored queries, optimizing the overall performance of their applications.
---

In this tutorial, we will integrate **Strawberry GraphQL** with **Relay** to enable persisted queries. This setup allows you to improve the performance of your GraphQL queries by storing them on the server and referencing them with a unique identifier.

### Step 1: Configure Relay on the Client Side

First, ensure you have Relay set up on your client side. You can do this by configuring your Relay environment. Make sure to specify the URL for the persisted query configuration in your `package.json`:

```json
{
  "relay": {
    "src": "./src",
    "language": "typescript",
    "schema": "../schema/schema.graphql",
    "persistConfig": {
      "url": "http://localhost:2999",
      "params": {}
    }
  }
}
```

Next, create a function to fetch queries, specifying the URL for your persisted query server:

```javascript
import { Environment, Network, RecordSource, Store } from 'relay-runtime'

function fetchQuery(operation, variables) {
  return fetch('http://localhost:8000/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      document_id: operation.id, // pass the persisted query ID
      variables,
    }),
  }).then((response) => {
    return response.json()
  })
}

const environment = new Environment({
  network: Network.create(fetchQuery),
  store: new Store(new RecordSource()),
})
```

### Step 2: Run the Persist Server

Next, create a Python script called `run_persist_server.py` to handle the persisted queries. Here’s the actual implementation of the script:

```python
import json
from hashlib import md5
from http.server import BaseHTTPRequestHandler, HTTPServer
from pathlib import Path
from urllib.parse import parse_qs

FILE_MAP_NAME = "query_map.json"

class QueryMap:
    def __init__(self, file_map_name: Path):
        self.file_map_name = file_map_name
        # Check if the file exists; if not, create an empty JSON file
        if Path.exists(self.file_map_name):
            with Path.open(self.file_map_name, "r") as file:
                self.query_map = json.load(file)
        else:
            self.query_map = {}
            self._flush()  # Create the file with an empty dictionary if it doesn't exist

    def _flush(self) -> None:
        with Path.open(self.file_map_name, "w") as file:
            json.dump(self.query_map, file)

    def save_query(self, text: str) -> str:
        query_id = md5(text.encode()).hexdigest()
        self.query_map[query_id] = text
        self._flush()
        return query_id

query_map = QueryMap(Path(FILE_MAP_NAME))

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        print("POST request received")
        if self.headers.get("Content-Type") != "application/x-www-form-urlencoded":
            self.send_response(400)
            self.end_headers()
            self.wfile.write(
                b'Only "application/x-www-form-urlencoded" requests are supported.'
            )
            return

        content_length = int(self.headers["Content-Length"])
        post_data = self.rfile.read(content_length).decode()
        params = parse_qs(post_data)
        text = params.get("text", [None])[0]

        if text is None:
            self.send_response(400)
            self.end_headers()
            self.wfile.write(b"Expected to have `text` parameter in the POST.")
            return

        query_id = query_map.save_query(text)
        response = json.dumps({"id": query_id}).encode()

        self.send_response(200)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(response)

if __name__ == "__main__":
    PORT = 2999
    server = HTTPServer(("127.0.0.1", PORT), SimpleHTTPRequestHandler)
    print(f"Server listening on port {PORT}")
    server.serve_forever()
```

You can run this script to start your GraphQL server, which will listen for requests on `http://localhost:2999`.

### Step 3: Create a Custom Strawberry GraphQL Schema Extension

To enable the usage of generated persisted queries, we’ll create a custom schema extension in Strawberry GraphQL. Here’s the implementation of the persisted queries extension:

```python
import json
from collections.abc import AsyncIterator, Iterator
from pathlib import Path
from graphql import ExecutionResult, GraphQLError
from strawberry.extensions import SchemaExtension

class PersistedQueriesExtension(SchemaExtension):
    def __init__(self, *, persisted_queries_path: Path) -> None:
        self.cache: dict[str, str] = {}

        with Path.open(persisted_queries_path, "r") as f:
            self.cache = json.load(f)

    async def on_execute(self):
        execution_context = self.execution_context
        body = await execution_context.context.get("request").json()
        document_id = body.get("document_id")
        persisted_query = self.cache.get(document_id)
        if persisted_query is None:
            self.execution_context.result = ExecutionResult(
                data=None,
                errors=[
                    GraphQLError("Invalid query provided."),
                ],
            )

    async def on_operation(self) -> AsyncIterator[None] | Iterator[None]:
        execution_context = self.execution_context
        body = await execution_context.context.get("request").json()
        document_id = body.get("document_id")
        persisted_query = self.cache.get(document_id)
        execution_context.query = persisted_query
        yield
```

### Conclusion

With this setup, you have integrated Strawberry GraphQL with Relay and configured persisted queries. This method enhances performance by allowing your application to reference and execute stored queries efficiently.

Make sure to explore further options with Strawberry and Relay to customize your setup according to your needs!
