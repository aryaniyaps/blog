---
title: Practical Dataloading with Strawberry GraphQL
date: '2025-03-24'
tags: ['strawberry-graphql', 'fastapi', 'backend', 'python', 'graphql']
draft: true
layout: PostSimple
images: []
summary: This blog post tackles the N+1 query problem in GraphQL by introducing dataloaders for batching requests and reducing database calls. It walks through setting up Aioinject, an async dependency injection library, to manage dataloader lifecycle efficiently with FastAPI and Strawberry GraphQL. The post explores three iterations of dataloader implementation, showing how to eliminate global state, improve performance, and support advanced features like key transformations and reusable factories.
---

Dataloaders are a necessary abstraction for efficient data fetching in GraphQL. This blog post explores how to practically implement data loading in Python,
alongside integration with [Aioinject](https://thirvondukr.github.io/aioinject/), an async Python dependency injection library.

## The N+1 Problem

GraphQL provides immense data loading capabilities to clients. But with great power, comes great responsibilities. It is easy to define queries like the 
one below, which can impact database performance if the resolvers under the hood are implemented naively.

Assuming the following GraphQL schema:

```graphql
 type Album {  
   id: ID!  
   title: String!  
   artistId: ID!  
 }

 type Musician {  
   id: ID!  
   name: String!  
   albums: [Album]  
 }

 type Query {  
   musicians: [Musician]  
 }
```

We can query the schema like:

```graphql
query MusiciansQuery {  
  musicians {  
    id,  
    name,  
    albums {  
      title  
    }  
  }  
}
```

A naive resolver implementation will fetch the the albums separately from the database on each musician returned, for the query.
Let’s say it finds *N* musicians in the database. For each musician found, the albums() resolver will be invoked to locate all the albums associated with that musician. 
This resolver will trigger a database call for each musician, which will be *N* calls. This means that in total, there will be *N+1* database calls occurring.

This is not very efficient and won’t scale after a point.


## Dataloaders to the rescue

Here's where dataloaders come to save the day! Dataloaders can batch similar client GraphQL requests into a single query. Basically, consider them as an intermediate layer that converts multiple similar requests to a single batched request. 
Its main tasks are:

- **Batching:** Instead of making a separate database or API call for every individual query from different resolvers, the DataLoader collects these requests and groups (or “batches”) them together. This way, a single query can retrieve multiple records at once.

- **Caching:** It temporarily stores (caches) results from data fetches during a single request cycle. If the same data is needed again, it can be returned from the cache without making another external call.

### How It Works Step-by-Step
<p align="left">
  <img src="/static/images/posts/practical-dataloading-strawberry-graphql/dataloaders-uml.png" />
</p>

1. **Request Collection:** When a GraphQL resolver requests data (for example, album information), it calls the DataLoader’s load(key) function. The DataLoader collects these requests for the current event loop tick.

2. **Batching and Execution:** At the end of the tick, the DataLoader calls a single batch function (often named batchLoad) with all the collected keys. This function fetches all the requested data in one go, such as via a single database query.

3. **Caching Results:** Once the batch function returns the data, the DataLoader caches the results. Any subsequent request for the same key within the same cycle will retrieve the data from the cache, avoiding redundant work.

4. **Resolver Return:** Finally, the GraphQL resolver receives the data from the DataLoader (either directly from the cache or from the fresh batch) and returns it to the client.



You can read more on dataloaders [here](https://strawberry.rocks/docs/guides/dataloaders).

## Initializing dataloaders

We need to share the dataloaders across all resolvers for a single request, so that the data can be batch-loaded and cached in the context of a single request.

Ideally, dataloaders will be initialized once per GraphQL request context. This can be done by defining the dataloaders as an attribute on the `Context` class in Strawberry GraphQL, or by utilizing a dependency injection library that 
caches the dataloaders for the scope of a single GraphQL request.

You can read more on this [here](https://strawberry.rocks/docs/guides/dataloaders#usage-with-context).


## Implementing data loading in a sample resolver

TODO:
introduce naive loader without DI here, emphasis on why DI is important
With DI, we can eliminate global state like database connections, and reuse resources efficiently

## Implementing dataloaders with Aioinject 

Now, we're going to implement dataloaders alongside dependency injection, provided by `Aioinject`.

### Setup Guide

- Step 1: Install Aioinject
```bash
pip install -U aioinject
```

- Step 2: Create an Aioinject container
```py:app/container.py
import aioinject

container = aioinject.Container()
```

- Step 3: [Integrate Aioinject with FastAPI](https://thirvondukr.github.io/aioinject/integrations/fastapi/)



- Step 4: [Integrate Aioinject with Strawberry GraphQL](https://thirvondukr.github.io/aioinject/integrations/strawberry-graphql/)


### Iteration 1- Directly injecting into the load function

Let us declare our dataloader load function, assuming that we have an account repository named `AccountRepo` that handles the data fetching for us.

```py:app/dataloaders.py
from typing import Annotated

from aioinject import Inject
from aioinject.ext.strawberry import inject

from app.repositories import AccountRepo

@inject
async def load_account_by_id(
    account_ids: list[str],
    account_repo: Annotated[AccountRepo, Inject],
) -> list[Account | None]:
    """Load multiple accounts by their IDs."""
    id_to_account_map = {
        account.id: account
        for account in await account_repo.get_many_by_ids(account_ids)
    }
    return [id_to_account_map.get(account_id) for account_id in account_ids]
```

Here, we are decorating the load function with the `@inject` decorator, and directly passing in dependencies as arguments.

Next, we need to create a custom context class to place the dataloader in.

```py:app/context.py
from typing import TypedDict

from fastapi import BackgroundTasks, Request, Response
from strawberry.dataloader import DataLoader
from strawberry.types import Info as StrawberryInfo

from app.models import Account

@dataclasses.dataclass(slots=True, kw_only=True)
class Dataloaders:
    account_by_id: DataLoader[str, Account | None]


class BaseContext(TypedDict):
    request: Request
    response: Response
    background_tasks: BackgroundTasks
    loaders: Dataloaders
```

We'll also create a function to initialize a new set of dataloaders for each request.

```py:app/context.py {8,23-28}
from typing import TypedDict

from fastapi import BackgroundTasks, Request, Response
from strawberry.dataloader import DataLoader
from strawberry.types import Info as StrawberryInfo

from app.models import Account
from app.dataloaders import load_account_by_id


@dataclasses.dataclass(slots=True, kw_only=True)
class Dataloaders:
    account_by_id: DataLoader[str, Account | None]


class BaseContext(TypedDict):
    request: Request
    response: Response
    background_tasks: BackgroundTasks
    loaders: Dataloaders


def create_dataloaders() -> Dataloaders:
    return Dataloaders(
        account_by_id=DataLoader(
            load_fn=load_account_by_id,  # type: ignore[arg-type]
        ),
    )
```

Now, we need to declare a custom GraphQL context getter that calls this intialization function.

```py:app/graphql_app.py
from typing import Annotated

from fastapi import BackgroundTasks, Request, Response
from strawberry.fastapi import GraphQLRouter

from .context import create_dataloaders, Context
from .schema import schema


async def get_context(
    request: Request,
    response: Response,
    background_tasks: BackgroundTasks,
) -> Context:
    return Context(
        request=request,
        response=response,
        background_tasks=background_tasks,
        loaders=create_dataloaders(),
    )


def create_graphql_router() -> GraphQLRouter:
    return GraphQLRouter(
        schema=schema,
        context_getter=get_context,
        graphql_ide="graphiql",
    )
```

Now, we can mount the GraphQL router (with the specified context getter) onto our FastAPI application.

#### ✅ Benefits
- Easy and straight-forward implementation.
- We are leveraging the powers of the DI framework to load resources efficiently.

#### ❌ Limitations
- Static type checkers are not happy- the load function is supposed to take in only one argument, *keys*.


### Iteration 2- Introduce dependency providers to create dataloaders per request

We can implement dataloading in a better way, by creating dependency providers that create dataloaders per request.

```py:app/dependencies.py
from strawberry.dataloader import DataLoader

from app.accounts.repositories import AccountRepo

from .models import Account


async def create_account_by_id_dataloader(
    account_repo: AccountRepo,
) -> DataLoader[str, Account | None]:
    """Create a dataloader to load accounts by their IDs."""
    async def load_fn(account_ids: list[str]) -> list[Account | None]:
        """Load multiple entities by their keys."""
        id_to_account_map = {
            account.id: account
            for account in await account_repo.get_many_by_ids(account_ids)
        }
        return [id_to_account_map.get(account_id) for account_id in account_ids]
    return Dataloader(load_fn=load_fn)
```

Next, we need to add this dependency provider to our Aioinject container.

```py:app/container.py {2, 5}
import aioinject
from app.dependencies import create_account_by_id_dataloader

container = aioinject.Container()
container.register(aioinject.Scoped(create_account_by_id_dataloader))
```

We also need to create a custom context class, like we did in the previous iteration.

```py:app/context.py
from typing import TypedDict

from fastapi import BackgroundTasks, Request, Response
from strawberry.dataloader import DataLoader
from strawberry.types import Info as StrawberryInfo

from app.models import Account


@dataclasses.dataclass(slots=True, kw_only=True)
class Dataloaders:
    account_by_id: DataLoader[str, Account | None]


class BaseContext(TypedDict):
    request: Request
    response: Response
    background_tasks: BackgroundTasks
    loaders: Dataloaders
```

But this time, we create another dependency provider that creates the dataloaders per request for us.

```py:app/dependencies.py {4, 22-28}
from strawberry.dataloader import DataLoader

from app.accounts.repositories import AccountRepo
from app.context import Dataloaders

from .models import Account


async def create_account_by_id_dataloader(
    account_repo: AccountRepo,
) -> DataLoader[str, Account | None]:
    """Create a dataloader to load accounts by their IDs."""
    async def load_fn(account_ids: list[str]) -> list[Account | None]:
        """Load multiple entities by their keys."""
        id_to_account_map = {
            account.id: account
            for account in await account_repo.get_many_by_ids(account_ids)
        }
        return [id_to_account_map.get(account_id) for account_id in account_ids]
    return Dataloader(load_fn=load_fn)

def create_dataloaders(
    account_by_id: DataLoader[str, Account | None],
) -> Dataloaders:
    """Create dataloaders for the current context."""
    return Dataloaders(
        account_by_id=account_by_id,
    )
```

We need to add this to the container too.

```py:app/container.py {2, 6}
import aioinject
from app.dependencies import create_account_by_id_dataloader, create_dataloaders

container = aioinject.Container()
container.register(aioinject.Scoped(create_account_by_id_dataloader))
container.register(aioinject.Scoped(create_dataloaders))
```

We can plug the dataloaders into the request context in the following way:
```py:app/graphql_app.py
from typing import Annotated

from aioinject import Injected
from aioinject.ext.fastapi import inject
from fastapi import BackgroundTasks, Request, Response
from strawberry.fastapi import GraphQLRouter

from .context import Context
from .dataloaders import Dataloaders
from .schema import schema


@inject
async def get_context(
    request: Request,
    response: Response,
    background_tasks: BackgroundTasks,
    dataloaders: Injected[Dataloaders],
) -> BaseContext:
    """Get the context for the GraphQL request."""
    return Context(
        request=request,
        response=response,
        background_tasks=background_tasks,
        loaders=dataloaders,
    )


def create_graphql_router() -> GraphQLRouter:
    """Create a GraphQL router."""
    return GraphQLRouter(
        schema=schema,
        context_getter=get_context,
        graphql_ide="apollo-sandbox",
    )
```

Now, this GraphQL router can be mounted onto your FastAPI application.

#### ✅ Benefits
- Static typecheckers are happy, we aren't violating any typing rules.
- We are leveraging the powers of the DI framework to load resources efficiently.

#### ❌ Limitations
- Lets say we have two dataloaders that load the same entity, with they same type of loading key:
  - **load_user_by_id** -> loads the user by a string attribute
  - **load_user_by_username** -> also loads the user by a string attribute

  Because Aioinject resolves dependencies based on type hints, we will have a duplicate dependency provider return type, and dependency resolution will fail.

### Iteration 3- Introduce type aliases for data loaders

Let us address the limitations in the previous iteration using [type aliases](https://typing.python.org/en/latest/spec/aliases.html), a new feature added since Python 3.11.

We can create type aliases for data loader dependency providers like follows:
```py:app/dependencies.py
from strawberry.dataloader import DataLoader

from app.accounts.repositories import AccountRepo
from app.context import Dataloaders

from .models import Account

type AccountByIdLoader = DataLoader[str, Account | None]

async def create_account_by_id_dataloader(
    account_repo: AccountRepo,
) -> AccountByIdLoader:
    """Create a dataloader to load accounts by their IDs."""
    async def load_fn(account_ids: list[str]) -> list[Account | None]:
        """Load multiple entities by their keys."""
        id_to_account_map = {
            account.id: account
            for account in await account_repo.get_many_by_ids(account_ids)
        }
        return [id_to_account_map.get(account_id) for account_id in account_ids]
    return Dataloader(load_fn=load_fn)

def create_dataloaders(
    account_by_id: AccountByIdLoader,
) -> Dataloaders:
    """Create dataloaders for the current context."""
    return Dataloaders(
        account_by_id=account_by_id,
    )
```

The use of type aliases provides an unique return type annotation for every dependency provider function, which plays nicely
with the Aioinject dependency injection system.

The remaining steps are similar to the previous iteration.

We register the dependency providers in the Aioinject container:

```py:app/container.py
import aioinject
from app.dependencies import create_account_by_id_dataloader, create_dataloaders

container = aioinject.Container()
container.register(aioinject.Scoped(create_account_by_id_dataloader))
container.register(aioinject.Scoped(create_dataloaders))
```

We can plug the dataloaders into the request context in the following way:
```py:app/graphql_app.py
from typing import Annotated

from aioinject import Injected
from aioinject.ext.fastapi import inject
from fastapi import BackgroundTasks, Request, Response
from strawberry.fastapi import GraphQLRouter

from .context import Context
from .dataloaders import Dataloaders
from .schema import schema


@inject
async def get_context(
    request: Request,
    response: Response,
    background_tasks: BackgroundTasks,
    dataloaders: Injected[Dataloaders],
) -> BaseContext:
    """Get the context for the GraphQL request."""
    return Context(
        request=request,
        response=response,
        background_tasks=background_tasks,
        loaders=dataloaders,
    )


def create_graphql_router() -> GraphQLRouter:
    """Create a GraphQL router."""
    return GraphQLRouter(
        schema=schema,
        context_getter=get_context,
        graphql_ide="apollo-sandbox",
    )
```

Now, this GraphQL router can be mounted onto your FastAPI application.

#### ✅ Benefits
- Static typecheckers are happy, we aren't violating any typing rules.
- We are leveraging the powers of the DI framework to load resources efficiently.
- We can have multiple data loaders with the same type annotations, uniquely identified by type aliases.

#### ❌ Limitations
- This approach might be a little verbose to implement


## Transforming dataloader keys
We might want to transform the provided keys to another type- like an integer, or an ObjectId, while using MongoDB, in some cases.
We can implement dataloader key transforms like so:


## Creating a dataloader factory function

We can encapsulate the dataloading logic into a reusable function like so:

```py
```

This dataloader factory function can be used to create multiple dataloaders like so:

```py
```