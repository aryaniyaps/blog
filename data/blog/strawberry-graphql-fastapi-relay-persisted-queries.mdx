---
title: Persisted Queries with Relay, Strawberry GraphQL and FastAPI
date: '2024-11-05'
tags: ['python', 'fastapi', 'graphql', 'relay', 'react']
draft: false
summary: In this tutorial, we’ll walk through how to integrate Strawberry GraphQL and FastAPI with Relay to enable persisted queries, which can significantly boost the performance of GraphQL applications. We’ll cover setting up a Relay environment on the client side, configuring a GraphQL server to handle persisted queries, and extending the Strawberry GraphQL schema to manage these queries.
---

In this tutorial, we’re going to explore how to set up persisted queries with Strawberry GraphQL, FastAPI and Relay. Persisted queries improve performance by letting the client send only a unique identifier for a query to the server, which then retrieves and executes the full query. This reduces the payload size, improves caching, and enhances security.

### What is Relay?

Relay is a powerful JavaScript framework developed by Facebook for managing data-fetching in React applications. It’s specifically designed to work with GraphQL and offers a streamlined way to manage queries and mutations. Relay helps optimize network requests and makes it easier to manage large applications by automatically handling caching, pagination, and data-fetching logic on the client side.

### What are Persisted Queries?

Persisted queries are GraphQL queries that are stored on the server with unique identifiers (query IDs). Instead of sending the entire query each time, the client can simply send the query ID along with any variables. The server can then retrieve and execute the stored query.

This approach offers several benefits:

- **Performance**: Reduces the payload size, especially useful for low-bandwidth clients.
- **Security**: Minimizes the chance of clients sending unvalidated or unintended queries.
- **Caching**: Allows easier caching of frequently used queries, reducing load on the server.

Let’s dive into the setup to implement persisted queries with Strawberry GraphQL and Relay.

---

There are two ways to setup persisted queries with relay:

1. **Server Persisted queries** - Run a local server that updates a query map server-side upon requests from the Relay client.
2. **Local Persisted queries** - Generate the query map client side (using Relay) and push it to the server at compile time/ runtime.

---

## Server Persisted Queries

In this section, we’ll implement persisted queries using a server-based method to store and manage query IDs.

### Step 1: Configure Relay on the Client Side

First, let’s configure Relay in the client application. Ensure Relay is set up properly and that the Relay environment is configured. In your package.json, add the Relay configuration with the URL of your persisted query server:

```json
{
  "relay": {
    "src": "./src",
    "language": "typescript",
    "schema": "./schema.graphql",
    "persistConfig": {
      "url": "http://localhost:2999",
      "params": {}
    }
  }
}
```

This configuration specifies the location of the schema file and the URL for the persisted query server.

Next, create a function to fetch the queries. This function should send the query ID to the persisted query server, which will retrieve and execute the query on the server.

```javascript
import { Environment, Network, RecordSource, Store } from 'relay-runtime'

function fetchQuery(operation, variables) {
  return fetch('http://localhost:8000/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      document_id: operation.id, // pass the persisted query ID
      variables,
    }),
  }).then((response) => {
    return response.json()
  })
}

const environment = new Environment({
  network: Network.create(fetchQuery),
  store: new Store(new RecordSource()),
})
```

This code sets up a Relay environment with a fetchQuery function that references the query by its unique ID, sending it to the server for execution.

### Step 2: Run the Persist Server

On the server side, we need a way to store and retrieve these persisted queries. Here’s a Python script, run_persist_server.py, that will act as a simple server for handling and saving these queries:

```python
import json
from hashlib import md5
from http.server import BaseHTTPRequestHandler, HTTPServer
from pathlib import Path
from urllib.parse import parse_qs

FILE_MAP_NAME = "query_map.json"

class QueryMap:
    def __init__(self, file_map_name: Path):
        self.file_map_name = file_map_name
        # Check if the file exists; if not, create an empty JSON file
        if Path.exists(self.file_map_name):
            with Path.open(self.file_map_name, "r") as file:
                self.query_map = json.load(file)
        else:
            self.query_map = {}
            self._flush()  # Create the file with an empty dictionary if it doesn't exist

    def _flush(self) -> None:
        with Path.open(self.file_map_name, "w") as file:
            json.dump(self.query_map, file)

    def save_query(self, text: str) -> str:
        query_id = md5(text.encode()).hexdigest()
        self.query_map[query_id] = text
        self._flush()
        return query_id

query_map = QueryMap(Path(FILE_MAP_NAME))

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        if self.headers.get("Content-Type") != "application/x-www-form-urlencoded":
            self.send_response(400)
            self.end_headers()
            self.wfile.write(
                b'Only "application/x-www-form-urlencoded" requests are supported.'
            )
            return

        content_length = int(self.headers["Content-Length"])
        post_data = self.rfile.read(content_length).decode()
        params = parse_qs(post_data)
        text = params.get("text", [None])[0]

        if text is None:
            self.send_response(400)
            self.end_headers()
            self.wfile.write(b"Expected to have `text` parameter in the POST.")
            return

        query_id = query_map.save_query(text)
        response = json.dumps({"id": query_id}).encode()

        self.send_response(200)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(response)

if __name__ == "__main__":
    PORT = 2999
    server = HTTPServer(("127.0.0.1", PORT), SimpleHTTPRequestHandler)
    print(f"Server listening on port {PORT}")
    server.serve_forever()
```

This server listens for requests on http://localhost:2999. When a client submits a query, the server hashes it to create a unique ID and stores it in query_map.json.

### Step 3: Create a Custom Strawberry GraphQL Schema Extension

To use persisted queries, we’ll extend our Strawberry GraphQL schema with a custom schema extension. This extension allows the server to recognize query IDs and look up the corresponding query text.

```python
import json
from collections.abc import AsyncIterator, Iterator
from pathlib import Path
from graphql import ExecutionResult, GraphQLError
from strawberry.extensions import SchemaExtension

class PersistedQueriesExtension(SchemaExtension):
    def __init__(self, *, persisted_queries_path: Path) -> None:
        self.cache: dict[str, str] = {}

        with Path.open(persisted_queries_path, "r") as f:
            self.cache = json.load(f)

    async def on_execute(self):
        execution_context = self.execution_context
        body = await execution_context.context.get("request").json()
        document_id = body.get("document_id")
        persisted_query = self.cache.get(document_id)
        if persisted_query is None:
            self.execution_context.result = ExecutionResult(
                data=None,
                errors=[
                    GraphQLError("Invalid query provided."),
                ],
            )

    async def on_operation(self) -> AsyncIterator[None] | Iterator[None]:
        execution_context = self.execution_context
        body = await execution_context.context.get("request").json()
        document_id = body.get("document_id")
        persisted_query = self.cache.get(document_id)
        execution_context.query = persisted_query
        yield
```

This extension retrieves queries from the `persisted_queries_path` and stores them in a cache. When a client requests a query, it checks if the query ID is valid. If the query isn’t found, an error is returned.

### Step 4: Add the Extension to Your Schema

Next, you need to add it to your Strawberry GraphQL schema. This is done by including the extension when instantiating the schema, so that the persisted query mechanism is activated for every request.

```python
from pathlib import Path

from strawberry import Schema
from app.extensions import PersistedQueriesExtension

schema = Schema(
    query=query,
    mutation=mutation,
    extensions=[
        PersistedQueriesExtension(
            persisted_queries_path=Path("query_map.json")
        ),
    ],
)
```

This completes the configuration, and your server is now ready to handle persisted queries.

---

## Local Persisted Queries

### Step 1: Configure Relay on the Client Side

First, let’s configure Relay in the client application. Ensure Relay is set up properly and that the Relay environment is configured. In your package.json, add the following Relay configuration:

```json
{
  "relay": {
    "src": "./src",
    "language": "typescript",
    "schema": "./schema.graphql",
    "persistConfig": {
      "file": "./persisted_queries.json",
      "algorithm": "MD5" // this can be one of MD5, SHA256, SHA1
    }
  }
}
```

This configuration specifies the location of the local persisted queries file.

Next, create a function to fetch the queries. This function should send the query ID to the persisted query server, which will retrieve and execute the query on the server.

```javascript
import { Environment, Network, RecordSource, Store } from 'relay-runtime'

function fetchQuery(operation, variables) {
  return fetch('http://localhost:8000/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      document_id: operation.id, // pass the persisted query ID
      variables,
    }),
  }).then((response) => {
    return response.json()
  })
}

const environment = new Environment({
  network: Network.create(fetchQuery),
  store: new Store(new RecordSource()),
})
```

This code sets up a Relay environment with a fetchQuery function that references the query by its unique ID, sending it to the server for execution.

### Step 2: Write a Script to Push Queries during Compile Time

Because our client and server projects are separate, a valid option is to have an additional npm run script to push the query map at compile time to a location accessible by your server:

```json
"scripts": {
  "push-queries": "node ./pushQueries.js",
  "relay": "relay-compiler && npm run push-queries"
}
```

Here is a script that pushes the `persisted_queries.json` file in the `client` directory to the `query_map.json` file in the server directory.

```javascript
const fs = require('fs')
const path = require('path')

// Define paths
const clientDir = path.join(__dirname, 'client')
const serverDir = path.join(__dirname, 'server')
const sourceFile = path.join(clientDir, 'persisted_queries.json')
const destFile = path.join(serverDir, 'query_map.json')

// Check if source file exists
fs.access(sourceFile, fs.constants.F_OK, (err) => {
  if (err) {
    console.error(`Source file ${sourceFile} does not exist.`)
    process.exit(1)
  } else {
    // Copy the file
    fs.copyFile(sourceFile, destFile, (err) => {
      if (err) {
        console.error(`Error copying file: ${err}`)
        process.exit(1)
      } else {
        console.log(`Copied ${sourceFile} to ${destFile}`)
      }
    })
  }
})
```

With this in place, every time the relay compiler runs, changes in persisted queries can be synced with the server.

### Step 3: Create a Custom Strawberry GraphQL Schema Extension

To use persisted queries, we’ll extend our Strawberry GraphQL schema with a custom schema extension. This extension allows the server to recognize query IDs and look up the corresponding query text.

```python
import json
from collections.abc import AsyncIterator, Iterator
from pathlib import Path
from graphql import ExecutionResult, GraphQLError
from strawberry.extensions import SchemaExtension

class PersistedQueriesExtension(SchemaExtension):
    def __init__(self, *, persisted_queries_path: Path) -> None:
        self.cache: dict[str, str] = {}

        with Path.open(persisted_queries_path, "r") as f:
            self.cache = json.load(f)

    async def on_execute(self):
        execution_context = self.execution_context
        body = await execution_context.context.get("request").json()
        document_id = body.get("document_id")
        persisted_query = self.cache.get(document_id)
        if persisted_query is None:
            self.execution_context.result = ExecutionResult(
                data=None,
                errors=[
                    GraphQLError("Invalid query provided."),
                ],
            )

    async def on_operation(self) -> AsyncIterator[None] | Iterator[None]:
        execution_context = self.execution_context
        body = await execution_context.context.get("request").json()
        document_id = body.get("document_id")
        persisted_query = self.cache.get(document_id)
        execution_context.query = persisted_query
        yield
```

This extension retrieves queries from the `persisted_queries_path` and stores them in a cache. When a client requests a query, it checks if the query ID is valid. If the query isn’t found, an error is returned.

### Step 4: Add the Extension to Your Schema

Next, you need to add it to your Strawberry GraphQL schema. This is done by including the extension when instantiating the schema, so that the persisted query mechanism is activated for every request.

```python
from pathlib import Path

from strawberry import Schema
from app.extensions import PersistedQueriesExtension

schema = Schema(
    query=query,
    mutation=mutation,
    extensions=[
        PersistedQueriesExtension(
            persisted_queries_path=Path("query_map.json")
        ),
    ],
)
```

This completes the configuration, and your server is now ready to handle persisted queries.

---

### Conclusion

You’ve now set up Strawberry GraphQL with Relay and enabled persisted queries! This approach optimizes performance by allowing your client application to reference and execute stored queries via unique identifiers. By setting up persisted queries, you can significantly reduce the payload size, enhance caching, and secure your GraphQL queries.

Consider exploring other features of Strawberry and Relay to further customize and optimize your GraphQL applications.

### Resources- Further Learning

- [GraphQL Relay- Persisted Queries](https://relay.dev/docs/guides/persisted-queries)
- [Understanding Persisted Queries](https://www.brightspot.com/documentation/brightspot-cms-developer-guide/graphql-understanding-persisted-queries)
- [Strawberry GraphQL- Custom Extensions](https://strawberry.rocks/docs/guides/custom-extensions)
- [Strawberry GraphQL- Relay](https://strawberry.rocks/docs/guides/relay)
